#!/usr/bin/awk -f 
# AWK PP, the awk preprocessor
# ----------------------------------------------------------------------------- 
# "THE BEER-WARE LICENSE" (Revision 43) borrowed from FreeBSD's jail.c: 
# <tag@cpan.org> wrote this file.  As long as you retain this notice you 
# can do whatever you want with this stuff. If we meet some day, and you think 
# this stuff is worth it, you can buy me a beer in return.   Scott S. McCoy 
# -----------------------------------------------------------------------------

# ord.awk --- do ord and chr

# Global identifiers:
#    _ord_:        numerical values indexed by characters
#    _ord_init:    function to initialize _ord_
#
# Arnold Robbins, arnold@gnu.org, Public Domain
# 16 January, 1992
# 20 July, 1992, revised

BEGIN    { _ord_init() }

function _ord_init(    low, high, i, t)
{
    low = sprintf("%c", 7) # BEL is ascii 7
    if (low == "\a") {    # regular ascii
        low = 0
        high = 127
    } else if (sprintf("%c", 128 + 7) == "\a") {
        # ascii, mark parity
        low = 128
        high = 255
    } else {        # ebcdic(!)
        low = 0
        high = 255
    }

    for (i = low; i <= high; i++) {
        t = sprintf("%c", i)
        _ord_[t] = i
    }
}
function ord(str,    c)
{
    # only first character is of interest
    c = substr(str, 1, 1)
    return _ord_[c]
}

function chr(c)
{
    # force c to be numeric by adding 0
    return sprintf("%c", c + 0)
}
# assert --- assert that a condition is true. Otherwise exit.

#
# Arnold Robbins, arnold@gnu.org, Public Domain
# May, 1993

function assert(condition, string)
{
    if (! condition) {
        printf("%s:%d: assertion failed: %s\n",
            FILENAME, FNR, string) > "/dev/stderr"
        _assert_exit = 1
        exit 1
    }
}

END {
    if (_assert_exit)
        exit 1
}
# awkbot/config.awk - A library for simple configuration file parsing
# ----------------------------------------------------------------------------- 
# "THE BEER-WARE LICENSE" (Revision 43) borrowed from FreeBSD's jail.c: 
# <tag@cpan.org> wrote this file.  As long as you retain this notice you 
# can do whatever you want with this stuff. If we meet some day, and you think 
# this stuff is worth it, you can buy me a beer in return.   Scott S. McCoy 
# -----------------------------------------------------------------------------
# deps: assert.awk

function config_load (filename) {
    _config["config", "filename"] = filename
    config_parse(_config, 0, filename)
}

# Recurse over new levels
function config_parse (config_data,level,filename    ,l,t,current,closing) {
    if (config_data["debug"]) 
        printf "config_parse(ARRAY, %s, %s)\n", level, filename

    while ( getline < filename ) {
        # Strip coments
        sub(/#.*$/, "")

        if (config_data["debug"]) {
            printf "read:%s:%d %s\n", filename, NR, $0
            print "Current namespace", level
        }

        if (/<[^/][^>]*>/) {
            match($0, /<([^/][^>]*)>/, l)
            if (config_data["debug"]) print "Opening: ", l[1]
            if (level) config_parse(config_data, level SUBSEP l[1], filename)
            else       config_parse(config_data, l[1],              filename)
        }
        else if (/<[/][^>]*>/) {
            match($0, /<[/]([^>]*)>/, l)
            t = split(l[1], l, SUBSEP)
            closing = l[t]
            t = split(level, l, SUBSEP)
            current = l[t]

            if (config_data["debug"]) print "Open", current, "close", closing
            assert((current == closing), "Inconsistent open/close tags")
            return
        }
        else {
            if (match($0, /([^ ][^ ]*)[ ]*(..*)/, l)) {
                if (config_data["debug"]) print level SUBSEP l[1], "=", l[2]
                if (level) config_data[level, l[1]] = l[2]
                else       config_data[l[1]]        = l[2]
            }
        }
    }
}

function config (item, value    ,element) {
    element = gensub(/\./, SUBSEP, "g", item)
    
    if (value) _config[element] = value
    if (_config["debug"]) print "config():", item, "(" element ")", value
# We should just treat undefined stuff as undefined *shrug*    
#    assert(_config[element], "config(): " element " is of no value")
    return _config[element]
}
# getopt.awk --- do C library getopt(3) function in awk
#
# Arnold Robbins, arnold@gnu.org, Public Domain
#
# Initial version: March, 1991
# Revised: May, 1993

# External variables:
#    Optind -- index in ARGV of first nonoption argument
#    Optarg -- string value of argument to current option
#    Opterr -- if nonzero, print our own diagnostic
#    Optopt -- current option letter

# Returns:
#    -1     at end of options
#    ?      for unrecognized option
#    <c>    a character representing the current option

# Private Data:
#    _opti  -- index in multi-flag option, e.g., -abc
function getopt(argc, argv, options,    thisopt, i)
{
    if (length(options) == 0)    # no options given
        return -1

    if (argv[Optind] == "--") {  # all done
        Optind++
        _opti = 0
        return -1
    } else if (argv[Optind] !~ /^-[^: \t\n\f\r\v\b]/) {
        _opti = 0
        return -1
    }
    if (_opti == 0)
        _opti = 2
    thisopt = substr(argv[Optind], _opti, 1)
    Optopt = thisopt
    i = index(options, thisopt)
    if (i == 0) {
        if (Opterr)
            printf("%c -- invalid option\n",
                                  thisopt) > "/dev/stderr"
        if (_opti >= length(argv[Optind])) {
            Optind++
            _opti = 0
        } else
            _opti++
        return "?"
    }
    if (substr(options, i + 1, 1) == ":") {
        # get option argument
        if (length(substr(argv[Optind], _opti + 1)) > 0)
            Optarg = substr(argv[Optind], _opti + 1)
        else
            Optarg = argv[++Optind]
        _opti = 0
    } else
        Optarg = ""
    if (_opti == 0 || _opti >= length(argv[Optind])) {
        Optind++
        _opti = 0
    } else
        _opti++
    return thisopt
}
BEGIN {
    Opterr = 1    # default is to diagnose
    Optind = 1    # skip ARGV[0]

    # test program
    if (_getopt_test) {
        while ((_go_c = getopt(ARGC, ARGV, "ab:cd")) != -1)
            printf("c = <%c>, optarg = <%s>\n",
                                       _go_c, Optarg)
        printf("non-option arguments:\n")
        for (; Optind < ARGC; Optind++)
            printf("\tARGV[%d] = <%s>\n",
                                    Optind, ARGV[Optind])
    }
}

BEGIN {
    # We need to do a better job of determining what awk we're running in here
    awk = "awk -f -"

    while ((opt = getopt(ARGC, ARGV, "sc:")) != -1) {
        if (opt == "c") config_file = Optarg
        if (opt == "s") awk = "cat"
    }

    if (config_file) {
        config_load(config_file)

        if (config("awkpp.define") ~ /^[0-9]+/) {
            for (i = 1; i <= config("awkpp.define"); i++) {
                # Define stuff
            }
        }
        else if (config("awkpp.define")) {
            # define one
        }
        if (config("awkpp.load") ~ /^[0-9]+/) {
            # include loop
        }
        else if (config("awkpp.load")) {
            # include one
        }
    }

    # File to processes
    filename = ARGV[--ARGC]

    for (i = 2; i <= ARGC; i++) {
        awk = awk " " ARGV[i]
        delete ARGV[i]
    }

#    while (ARGC > 1) proc_include(ARGV[--ARGC])
    proc_include(filename)

    printf chr(10) | awk
    close(awk)
}

function proc_include (filename     ,stop,il,path,k,location,test,junk) {
    split(ENVIRON["AWKPATH"], path, ":")

    for (k = 1; path[k]; k++) {
        test = path[k] "/" filename
        if ((getline junk <test) >= 0) {
            close(test)
            location = test
            break
        }
    }

    assert(location, "Unable to locate: " filename " in " ENVIRON["AWKPATH"])

    while (getline < location) proc_run(location)
}

function proc_run (location     ,il,junk,macro) {
        if (match($0, /^#define ([[:alnum:]]*)  *([^\\]*)\\? *$/, il)) {
            define[il[1]] = il[2]
            while ($NF == "\\") {
                getline junk < location
                define[il[1]] = define[il[1]] junk
            }
        }
        else if (match($0, /^#if(n?)def ([[:alnum:]]*)$/, il)) {
            if ((il[1] && ! define[il[2]]) || define[il[2]]) {
                while (getline < location) {
                    if (/^#else/) {
                        while (!/^#endif/) getline < location
                        return
                    }
                    if (/^#endif/) return
                    proc_run(location)
                }
            }
            else {
                while (getline < location) {
                    if (/^#else/) {
                        getline < location           # Skip this line
                        while (!/^#endif/) {
                            proc_run(location)       # This strange way of
                            getline < location       # doing things is to make
                        }                            # sure the macros get
                        return                       # stripped
                    }
                }
            }
        }
        else if (match($0, /^#include <([^>]+)>/, il)) {
            if (!included[il[1]]) {
                included[il[1]] = 1
                proc_include(il[1])
            }
        }
        else {
            for (macro in define) gsub(macro, define[macro])
            print | awk
        }
}


